/* dconf-schema.c generated by valac 0.19.0.3-f335, the Vala compiler
 * generated from dconf-schema.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_SCHEMA_KEY (schema_key_get_type ())
#define SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_KEY, SchemaKey))
#define SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_KEY, SchemaKeyClass))
#define IS_SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_KEY))
#define IS_SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_KEY))
#define SCHEMA_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_KEY, SchemaKeyClass))

typedef struct _SchemaKey SchemaKey;
typedef struct _SchemaKeyClass SchemaKeyClass;
typedef struct _SchemaKeyPrivate SchemaKeyPrivate;

#define TYPE_SCHEMA (schema_get_type ())
#define SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA, Schema))
#define SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA, SchemaClass))
#define IS_SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA))
#define IS_SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA))
#define SCHEMA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA, SchemaClass))

typedef struct _Schema Schema;
typedef struct _SchemaClass SchemaClass;

#define TYPE_SCHEMA_VALUE_RANGE (schema_value_range_get_type ())
#define SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRange))
#define SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))
#define IS_SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_VALUE_RANGE))
#define IS_SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_VALUE_RANGE))
#define SCHEMA_VALUE_RANGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))

typedef struct _SchemaValueRange SchemaValueRange;
typedef struct _SchemaValueRangeClass SchemaValueRangeClass;

#define TYPE_SCHEMA_CHOICE (schema_choice_get_type ())
#define SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_CHOICE, SchemaChoice))
#define SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))
#define IS_SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_CHOICE))
#define IS_SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_CHOICE))
#define SCHEMA_CHOICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))

typedef struct _SchemaChoice SchemaChoice;
typedef struct _SchemaChoiceClass SchemaChoiceClass;
#define _schema_unref0(var) ((var == NULL) ? NULL : (var = (schema_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _schema_value_range_unref0(var) ((var == NULL) ? NULL : (var = (schema_value_range_unref (var), NULL)))
#define __g_list_free__schema_choice_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__schema_choice_unref0_ (var), NULL)))
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _ParamSpecSchemaKey ParamSpecSchemaKey;

#define TYPE_SCHEMA_VALUE (schema_value_get_type ())
#define SCHEMA_VALUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_VALUE, SchemaValue))
#define SCHEMA_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_VALUE, SchemaValueClass))
#define IS_SCHEMA_VALUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_VALUE))
#define IS_SCHEMA_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_VALUE))
#define SCHEMA_VALUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_VALUE, SchemaValueClass))

typedef struct _SchemaValue SchemaValue;
typedef struct _SchemaValueClass SchemaValueClass;
typedef struct _SchemaValuePrivate SchemaValuePrivate;
typedef struct _SchemaChoicePrivate SchemaChoicePrivate;
typedef struct _ParamSpecSchemaChoice ParamSpecSchemaChoice;
typedef struct _SchemaValueRangePrivate SchemaValueRangePrivate;
typedef struct _ParamSpecSchemaValueRange ParamSpecSchemaValueRange;

#define TYPE_SCHEMA_ENUM (schema_enum_get_type ())
#define SCHEMA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_ENUM, SchemaEnum))
#define SCHEMA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_ENUM, SchemaEnumClass))
#define IS_SCHEMA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_ENUM))
#define IS_SCHEMA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_ENUM))
#define SCHEMA_ENUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_ENUM, SchemaEnumClass))

typedef struct _SchemaEnum SchemaEnum;
typedef struct _SchemaEnumClass SchemaEnumClass;
typedef struct _SchemaEnumPrivate SchemaEnumPrivate;

#define TYPE_SCHEMA_LIST (schema_list_get_type ())
#define SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_LIST, SchemaList))
#define SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_LIST, SchemaListClass))
#define IS_SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_LIST))
#define IS_SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_LIST))
#define SCHEMA_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_LIST, SchemaListClass))

typedef struct _SchemaList SchemaList;
typedef struct _SchemaListClass SchemaListClass;
#define _schema_list_unref0(var) ((var == NULL) ? NULL : (var = (schema_list_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _ParamSpecSchemaEnum ParamSpecSchemaEnum;

#define TYPE_SCHEMA_FLAGS (schema_flags_get_type ())
#define SCHEMA_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_FLAGS, SchemaFlags))
#define SCHEMA_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_FLAGS, SchemaFlagsClass))
#define IS_SCHEMA_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_FLAGS))
#define IS_SCHEMA_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_FLAGS))
#define SCHEMA_FLAGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_FLAGS, SchemaFlagsClass))

typedef struct _SchemaFlags SchemaFlags;
typedef struct _SchemaFlagsClass SchemaFlagsClass;
typedef struct _SchemaFlagsPrivate SchemaFlagsPrivate;
typedef struct _ParamSpecSchemaFlags ParamSpecSchemaFlags;
typedef struct _SchemaPrivate SchemaPrivate;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _schema_key_unref0(var) ((var == NULL) ? NULL : (var = (schema_key_unref (var), NULL)))
typedef struct _ParamSpecSchema ParamSpecSchema;
typedef struct _SchemaListPrivate SchemaListPrivate;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _schema_enum_unref0(var) ((var == NULL) ? NULL : (var = (schema_enum_unref (var), NULL)))
#define _schema_flags_unref0(var) ((var == NULL) ? NULL : (var = (schema_flags_unref (var), NULL)))
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
typedef struct _ParamSpecSchemaList ParamSpecSchemaList;

struct _SchemaKey {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaKeyPrivate * priv;
	Schema* schema;
	gchar* name;
	gchar* type;
	GVariant* default_value;
	SchemaValueRange* range;
	SchemaValueRange* type_range;
	GList* choices;
	gchar* enum_name;
	gchar* summary;
	gchar* description;
	gchar* gettext_domain;
};

struct _SchemaKeyClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaKey *self);
};

struct _ParamSpecSchemaKey {
	GParamSpec parent_instance;
};

struct _SchemaValue {
	GObject parent_instance;
	SchemaValuePrivate * priv;
	guint index;
	gchar* nick;
	gint value;
};

struct _SchemaValueClass {
	GObjectClass parent_class;
};

struct _SchemaChoice {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaChoicePrivate * priv;
	gchar* name;
	GVariant* value;
};

struct _SchemaChoiceClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaChoice *self);
};

struct _ParamSpecSchemaChoice {
	GParamSpec parent_instance;
};

struct _SchemaValueRange {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaValueRangePrivate * priv;
	GVariant* min;
	GVariant* max;
};

struct _SchemaValueRangeClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaValueRange *self);
};

struct _ParamSpecSchemaValueRange {
	GParamSpec parent_instance;
};

struct _SchemaEnum {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaEnumPrivate * priv;
	SchemaList* list;
	gchar* id;
	GList* values;
};

struct _SchemaEnumClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaEnum *self);
};

struct _ParamSpecSchemaEnum {
	GParamSpec parent_instance;
};

struct _SchemaFlags {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaFlagsPrivate * priv;
	SchemaList* list;
	gchar* id;
	GList* values;
};

struct _SchemaFlagsClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaFlags *self);
};

struct _ParamSpecSchemaFlags {
	GParamSpec parent_instance;
};

struct _Schema {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaPrivate * priv;
	SchemaList* list;
	gchar* id;
	gchar* path;
	GHashTable* keys;
};

struct _SchemaClass {
	GTypeClass parent_class;
	void (*finalize) (Schema *self);
};

struct _ParamSpecSchema {
	GParamSpec parent_instance;
};

struct _SchemaList {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaListPrivate * priv;
	GHashTable* schemas;
	GHashTable* keys;
	GHashTable* enums;
	GHashTable* flags;
};

struct _SchemaListClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaList *self);
};

struct _ParamSpecSchemaList {
	GParamSpec parent_instance;
};


static gpointer schema_key_parent_class = NULL;
static gpointer schema_value_parent_class = NULL;
static gpointer schema_choice_parent_class = NULL;
static gpointer schema_value_range_parent_class = NULL;
static gpointer schema_enum_parent_class = NULL;
static gpointer schema_flags_parent_class = NULL;
static gpointer schema_parent_class = NULL;
static gpointer schema_list_parent_class = NULL;

gpointer schema_key_ref (gpointer instance);
void schema_key_unref (gpointer instance);
GParamSpec* param_spec_schema_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_key (GValue* value, gpointer v_object);
void value_take_schema_key (GValue* value, gpointer v_object);
gpointer value_get_schema_key (const GValue* value);
GType schema_key_get_type (void) G_GNUC_CONST;
gpointer schema_ref (gpointer instance);
void schema_unref (gpointer instance);
GParamSpec* param_spec_schema (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema (GValue* value, gpointer v_object);
void value_take_schema (GValue* value, gpointer v_object);
gpointer value_get_schema (const GValue* value);
GType schema_get_type (void) G_GNUC_CONST;
gpointer schema_value_range_ref (gpointer instance);
void schema_value_range_unref (gpointer instance);
GParamSpec* param_spec_schema_value_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_value_range (GValue* value, gpointer v_object);
void value_take_schema_value_range (GValue* value, gpointer v_object);
gpointer value_get_schema_value_range (const GValue* value);
GType schema_value_range_get_type (void) G_GNUC_CONST;
gpointer schema_choice_ref (gpointer instance);
void schema_choice_unref (gpointer instance);
GParamSpec* param_spec_schema_choice (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_choice (GValue* value, gpointer v_object);
void value_take_schema_choice (GValue* value, gpointer v_object);
gpointer value_get_schema_choice (const GValue* value);
GType schema_choice_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_KEY_DUMMY_PROPERTY
};
static void _schema_choice_unref0_ (gpointer var);
static void _g_list_free__schema_choice_unref0_ (GList* self);
SchemaKey* schema_key_new_from_xml (xmlNode* node, Schema* schema, const gchar* gettext_domain);
SchemaKey* schema_key_construct_from_xml (GType object_type, xmlNode* node, Schema* schema, const gchar* gettext_domain);
SchemaValueRange* schema_value_range_new_from_xml (const gchar* type, xmlNode* node);
SchemaValueRange* schema_value_range_construct_from_xml (GType object_type, const gchar* type, xmlNode* node);
SchemaChoice* schema_choice_new (const gchar* name, GVariant* value);
SchemaChoice* schema_choice_construct (GType object_type, const gchar* name, GVariant* value);
SchemaKey* schema_key_new (void);
SchemaKey* schema_key_construct (GType object_type);
static void schema_key_finalize (SchemaKey* obj);
GType schema_value_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_VALUE_DUMMY_PROPERTY
};
SchemaValue* schema_value_new (guint index, const gchar* nick, gint value);
SchemaValue* schema_value_construct (GType object_type, guint index, const gchar* nick, gint value);
static void schema_value_finalize (GObject* obj);
enum  {
	SCHEMA_CHOICE_DUMMY_PROPERTY
};
static void schema_choice_finalize (SchemaChoice* obj);
enum  {
	SCHEMA_VALUE_RANGE_DUMMY_PROPERTY
};
SchemaValueRange* schema_value_range_new (void);
SchemaValueRange* schema_value_range_construct (GType object_type);
static void schema_value_range_finalize (SchemaValueRange* obj);
gpointer schema_enum_ref (gpointer instance);
void schema_enum_unref (gpointer instance);
GParamSpec* param_spec_schema_enum (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_enum (GValue* value, gpointer v_object);
void value_take_schema_enum (GValue* value, gpointer v_object);
gpointer value_get_schema_enum (const GValue* value);
GType schema_enum_get_type (void) G_GNUC_CONST;
gpointer schema_list_ref (gpointer instance);
void schema_list_unref (gpointer instance);
GParamSpec* param_spec_schema_list (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_list (GValue* value, gpointer v_object);
void value_take_schema_list (GValue* value, gpointer v_object);
gpointer value_get_schema_list (const GValue* value);
GType schema_list_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_ENUM_DUMMY_PROPERTY
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
SchemaEnum* schema_enum_new_from_xml (SchemaList* list, xmlNode* node);
SchemaEnum* schema_enum_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node);
SchemaEnum* schema_enum_new (void);
SchemaEnum* schema_enum_construct (GType object_type);
static void schema_enum_finalize (SchemaEnum* obj);
gpointer schema_flags_ref (gpointer instance);
void schema_flags_unref (gpointer instance);
GParamSpec* param_spec_schema_flags (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_flags (GValue* value, gpointer v_object);
void value_take_schema_flags (GValue* value, gpointer v_object);
gpointer value_get_schema_flags (const GValue* value);
GType schema_flags_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_FLAGS_DUMMY_PROPERTY
};
SchemaFlags* schema_flags_new_from_xml (SchemaList* list, xmlNode* node);
SchemaFlags* schema_flags_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node);
SchemaFlags* schema_flags_new (void);
SchemaFlags* schema_flags_construct (GType object_type);
static void schema_flags_finalize (SchemaFlags* obj);
enum  {
	SCHEMA_DUMMY_PROPERTY
};
static void _g_free0_ (gpointer var);
static void _schema_key_unref0_ (gpointer var);
Schema* schema_new_from_xml (SchemaList* list, xmlNode* node, const gchar* gettext_domain);
Schema* schema_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node, const gchar* gettext_domain);
Schema* schema_new (void);
Schema* schema_construct (GType object_type);
static void schema_finalize (Schema* obj);
enum  {
	SCHEMA_LIST_DUMMY_PROPERTY
};
static void _schema_unref0_ (gpointer var);
static void _schema_enum_unref0_ (gpointer var);
static void _schema_flags_unref0_ (gpointer var);
void schema_list_parse_file (SchemaList* self, const gchar* path);
void schema_list_parse_override (SchemaList* self, const gchar* path);
void schema_list_load_directory (SchemaList* self, const gchar* dir, GError** error);
SchemaList* schema_list_new (void);
SchemaList* schema_list_construct (GType object_type);
static void schema_list_finalize (SchemaList* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _schema_choice_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_choice_unref (var), NULL));
}


static void _g_list_free__schema_choice_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _schema_choice_unref0_, NULL);
	g_list_free (self);
}


static gpointer _schema_ref0 (gpointer self) {
	return self ? schema_ref (self) : NULL;
}


SchemaKey* schema_key_construct_from_xml (GType object_type, xmlNode* node, Schema* schema, const gchar* gettext_domain) {
	SchemaKey* self = NULL;
	Schema* _tmp0_;
	Schema* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (schema != NULL, NULL);
	self = (SchemaKey*) g_type_create_instance (object_type);
	_tmp0_ = schema;
	_tmp1_ = _schema_ref0 (_tmp0_);
	_schema_unref0 (self->schema);
	self->schema = _tmp1_;
	_tmp2_ = gettext_domain;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->gettext_domain);
	self->gettext_domain = _tmp3_;
	{
		xmlNode* _tmp4_;
		xmlAttr* _tmp5_;
		xmlAttr* prop;
		_tmp4_ = node;
		_tmp5_ = _tmp4_->properties;
		prop = _tmp5_;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				xmlAttr* _tmp10_;
				xmlAttr* _tmp11_;
				const gchar* _tmp12_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					xmlAttr* _tmp8_;
					xmlAttr* _tmp9_;
					_tmp8_ = prop;
					_tmp9_ = _tmp8_->next;
					prop = _tmp9_;
				}
				_tmp6_ = FALSE;
				_tmp10_ = prop;
				if (!(_tmp10_ != NULL)) {
					break;
				}
				_tmp11_ = prop;
				_tmp12_ = _tmp11_->name;
				if (g_strcmp0 (_tmp12_, "name") == 0) {
					xmlAttr* _tmp13_;
					xmlNode* _tmp14_;
					const gchar* _tmp15_;
					gchar* _tmp16_;
					_tmp13_ = prop;
					_tmp14_ = _tmp13_->children;
					_tmp15_ = _tmp14_->content;
					_tmp16_ = g_strdup (_tmp15_);
					_g_free0 (self->name);
					self->name = _tmp16_;
				} else {
					xmlAttr* _tmp17_;
					const gchar* _tmp18_;
					_tmp17_ = prop;
					_tmp18_ = _tmp17_->name;
					if (g_strcmp0 (_tmp18_, "type") == 0) {
						xmlAttr* _tmp19_;
						xmlNode* _tmp20_;
						const gchar* _tmp21_;
						gchar* _tmp22_;
						_tmp19_ = prop;
						_tmp20_ = _tmp19_->children;
						_tmp21_ = _tmp20_->content;
						_tmp22_ = g_strdup (_tmp21_);
						_g_free0 (self->type);
						self->type = _tmp22_;
					} else {
						xmlAttr* _tmp23_;
						const gchar* _tmp24_;
						_tmp23_ = prop;
						_tmp24_ = _tmp23_->name;
						if (g_strcmp0 (_tmp24_, "enum") == 0) {
							gchar* _tmp25_;
							xmlAttr* _tmp26_;
							xmlNode* _tmp27_;
							const gchar* _tmp28_;
							gchar* _tmp29_;
							_tmp25_ = g_strdup ("s");
							_g_free0 (self->type);
							self->type = _tmp25_;
							_tmp26_ = prop;
							_tmp27_ = _tmp26_->children;
							_tmp28_ = _tmp27_->content;
							_tmp29_ = g_strdup (_tmp28_);
							_g_free0 (self->enum_name);
							self->enum_name = _tmp29_;
						} else {
							xmlAttr* _tmp30_;
							const gchar* _tmp31_;
							_tmp30_ = prop;
							_tmp31_ = _tmp30_->name;
							if (g_strcmp0 (_tmp31_, "flags") == 0) {
								gchar* _tmp32_;
								_tmp32_ = g_strdup ("as");
								_g_free0 (self->type);
								self->type = _tmp32_;
							} else {
								xmlAttr* _tmp33_;
								const gchar* _tmp34_;
								_tmp33_ = prop;
								_tmp34_ = _tmp33_->name;
								g_warning ("dconf-schema.vala:35: Unknown property on <key>, %s", _tmp34_);
							}
						}
					}
				}
			}
		}
	}
	{
		xmlNode* _tmp35_;
		xmlNode* _tmp36_;
		xmlNode* child;
		_tmp35_ = node;
		_tmp36_ = _tmp35_->children;
		child = _tmp36_;
		{
			gboolean _tmp37_;
			_tmp37_ = TRUE;
			while (TRUE) {
				gboolean _tmp38_;
				xmlNode* _tmp41_;
				xmlNode* _tmp42_;
				const gchar* _tmp43_;
				_tmp38_ = _tmp37_;
				if (!_tmp38_) {
					xmlNode* _tmp39_;
					xmlNode* _tmp40_;
					_tmp39_ = child;
					_tmp40_ = _tmp39_->next;
					child = _tmp40_;
				}
				_tmp37_ = FALSE;
				_tmp41_ = child;
				if (!(_tmp41_ != NULL)) {
					break;
				}
				_tmp42_ = child;
				_tmp43_ = _tmp42_->name;
				if (g_strcmp0 (_tmp43_, "default") == 0) {
					{
						const gchar* _tmp44_;
						GVariantType* _tmp45_;
						GVariantType* _tmp46_;
						xmlNode* _tmp47_;
						gchar* _tmp48_ = NULL;
						gchar* _tmp49_;
						GVariant* _tmp50_ = NULL;
						GVariant* _tmp51_;
						GVariant* _tmp52_;
						_tmp44_ = self->type;
						_tmp45_ = g_variant_type_new (_tmp44_);
						_tmp46_ = _tmp45_;
						_tmp47_ = child;
						_tmp48_ = xmlNodeGetContent (_tmp47_);
						_tmp49_ = _tmp48_;
						_tmp50_ = g_variant_parse (_tmp46_, _tmp49_, NULL, NULL, &_inner_error_);
						_tmp51_ = _tmp50_;
						_g_free0 (_tmp49_);
						_g_variant_type_free0 (_tmp46_);
						_tmp52_ = _tmp51_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
								goto __catch5_g_variant_parse_error;
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
						_g_variant_unref0 (self->default_value);
						self->default_value = _tmp52_;
					}
					goto __finally5;
					__catch5_g_variant_parse_error:
					{
						GError* e = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_g_error_free0 (e);
					}
					__finally5:
					if (_inner_error_ != NULL) {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				} else {
					xmlNode* _tmp53_;
					const gchar* _tmp54_;
					_tmp53_ = child;
					_tmp54_ = _tmp53_->name;
					if (g_strcmp0 (_tmp54_, "summary") == 0) {
						xmlNode* _tmp55_;
						gchar* _tmp56_ = NULL;
						_tmp55_ = child;
						_tmp56_ = xmlNodeGetContent (_tmp55_);
						_g_free0 (self->summary);
						self->summary = _tmp56_;
					} else {
						xmlNode* _tmp57_;
						const gchar* _tmp58_;
						_tmp57_ = child;
						_tmp58_ = _tmp57_->name;
						if (g_strcmp0 (_tmp58_, "description") == 0) {
							xmlNode* _tmp59_;
							gchar* _tmp60_ = NULL;
							_tmp59_ = child;
							_tmp60_ = xmlNodeGetContent (_tmp59_);
							_g_free0 (self->description);
							self->description = _tmp60_;
						} else {
							xmlNode* _tmp61_;
							const gchar* _tmp62_;
							_tmp61_ = child;
							_tmp62_ = _tmp61_->name;
							if (g_strcmp0 (_tmp62_, "range") == 0) {
								const gchar* _tmp63_;
								xmlNode* _tmp64_;
								SchemaValueRange* _tmp65_;
								_tmp63_ = self->type;
								_tmp64_ = child;
								_tmp65_ = schema_value_range_new_from_xml (_tmp63_, _tmp64_);
								_schema_value_range_unref0 (self->range);
								self->range = _tmp65_;
							} else {
								xmlNode* _tmp66_;
								const gchar* _tmp67_;
								_tmp66_ = child;
								_tmp67_ = _tmp66_->name;
								if (g_strcmp0 (_tmp67_, "choices") == 0) {
									{
										xmlNode* _tmp68_;
										xmlNode* _tmp69_;
										xmlNode* n;
										_tmp68_ = child;
										_tmp69_ = _tmp68_->children;
										n = _tmp69_;
										{
											gboolean _tmp70_;
											_tmp70_ = TRUE;
											while (TRUE) {
												gboolean _tmp71_;
												xmlNode* _tmp74_;
												xmlNode* _tmp75_;
												xmlElementType _tmp76_;
												xmlNode* _tmp77_;
												const gchar* _tmp78_;
												gchar* value;
												const gchar* _tmp96_;
												const gchar* _tmp97_;
												GVariant* _tmp98_;
												GVariant* v;
												const gchar* _tmp99_;
												GVariant* _tmp100_;
												SchemaChoice* _tmp101_;
												_tmp71_ = _tmp70_;
												if (!_tmp71_) {
													xmlNode* _tmp72_;
													xmlNode* _tmp73_;
													_tmp72_ = n;
													_tmp73_ = _tmp72_->next;
													n = _tmp73_;
												}
												_tmp70_ = FALSE;
												_tmp74_ = n;
												if (!(_tmp74_ != NULL)) {
													break;
												}
												_tmp75_ = n;
												_tmp76_ = _tmp75_->type;
												if (_tmp76_ != XML_ELEMENT_NODE) {
													continue;
												}
												_tmp77_ = n;
												_tmp78_ = _tmp77_->name;
												if (g_strcmp0 (_tmp78_, "choice") != 0) {
													xmlNode* _tmp79_;
													const gchar* _tmp80_;
													_tmp79_ = n;
													_tmp80_ = _tmp79_->name;
													g_warning ("dconf-schema.vala:68: Unknown child tag in <choices>, <%s>", _tmp80_);
													continue;
												}
												value = NULL;
												{
													xmlNode* _tmp81_;
													xmlAttr* _tmp82_;
													xmlAttr* prop;
													_tmp81_ = n;
													_tmp82_ = _tmp81_->properties;
													prop = _tmp82_;
													{
														gboolean _tmp83_;
														_tmp83_ = TRUE;
														while (TRUE) {
															gboolean _tmp84_;
															xmlAttr* _tmp87_;
															xmlAttr* _tmp88_;
															const gchar* _tmp89_;
															_tmp84_ = _tmp83_;
															if (!_tmp84_) {
																xmlAttr* _tmp85_;
																xmlAttr* _tmp86_;
																_tmp85_ = prop;
																_tmp86_ = _tmp85_->next;
																prop = _tmp86_;
															}
															_tmp83_ = FALSE;
															_tmp87_ = prop;
															if (!(_tmp87_ != NULL)) {
																break;
															}
															_tmp88_ = prop;
															_tmp89_ = _tmp88_->name;
															if (g_strcmp0 (_tmp89_, "value") == 0) {
																xmlAttr* _tmp90_;
																xmlNode* _tmp91_;
																const gchar* _tmp92_;
																gchar* _tmp93_;
																_tmp90_ = prop;
																_tmp91_ = _tmp90_->children;
																_tmp92_ = _tmp91_->content;
																_tmp93_ = g_strdup (_tmp92_);
																_g_free0 (value);
																value = _tmp93_;
															} else {
																xmlAttr* _tmp94_;
																const gchar* _tmp95_;
																_tmp94_ = prop;
																_tmp95_ = _tmp94_->name;
																g_warning ("dconf-schema.vala:78: Unknown property on <choice>, %s", _tmp95_);
															}
														}
													}
												}
												_tmp96_ = value;
												if (_tmp96_ == NULL) {
													g_warning ("dconf-schema.vala:83: Ignoring <choice> with no value");
													_g_free0 (value);
													continue;
												}
												_tmp97_ = value;
												_tmp98_ = g_variant_new_string (_tmp97_);
												g_variant_ref_sink (_tmp98_);
												v = _tmp98_;
												_tmp99_ = value;
												_tmp100_ = v;
												_tmp101_ = schema_choice_new (_tmp99_, _tmp100_);
												self->choices = g_list_append (self->choices, _tmp101_);
												_g_variant_unref0 (v);
												_g_free0 (value);
											}
										}
									}
								} else {
									xmlNode* _tmp102_;
									const gchar* _tmp103_;
									_tmp102_ = child;
									_tmp103_ = _tmp102_->name;
									if (g_strcmp0 (_tmp103_, "aliases") == 0) {
										{
											xmlNode* _tmp104_;
											xmlNode* _tmp105_;
											xmlNode* n;
											_tmp104_ = child;
											_tmp105_ = _tmp104_->children;
											n = _tmp105_;
											{
												gboolean _tmp106_;
												_tmp106_ = TRUE;
												while (TRUE) {
													gboolean _tmp107_;
													xmlNode* _tmp110_;
													xmlNode* _tmp111_;
													xmlElementType _tmp112_;
													xmlNode* _tmp113_;
													const gchar* _tmp114_;
													gchar* value;
													gchar* target;
													const gchar* _tmp138_;
													const gchar* _tmp139_;
													const gchar* _tmp140_;
													GVariant* _tmp141_;
													GVariant* v;
													const gchar* _tmp142_;
													GVariant* _tmp143_;
													SchemaChoice* _tmp144_;
													_tmp107_ = _tmp106_;
													if (!_tmp107_) {
														xmlNode* _tmp108_;
														xmlNode* _tmp109_;
														_tmp108_ = n;
														_tmp109_ = _tmp108_->next;
														n = _tmp109_;
													}
													_tmp106_ = FALSE;
													_tmp110_ = n;
													if (!(_tmp110_ != NULL)) {
														break;
													}
													_tmp111_ = n;
													_tmp112_ = _tmp111_->type;
													if (_tmp112_ != XML_ELEMENT_NODE) {
														continue;
													}
													_tmp113_ = n;
													_tmp114_ = _tmp113_->name;
													if (g_strcmp0 (_tmp114_, "alias") != 0) {
														xmlNode* _tmp115_;
														const gchar* _tmp116_;
														_tmp115_ = n;
														_tmp116_ = _tmp115_->name;
														g_warning ("dconf-schema.vala:99: Unknown child tag in <aliases>, <%s>", _tmp116_);
														continue;
													}
													value = NULL;
													target = NULL;
													{
														xmlNode* _tmp117_;
														xmlAttr* _tmp118_;
														xmlAttr* prop;
														_tmp117_ = n;
														_tmp118_ = _tmp117_->properties;
														prop = _tmp118_;
														{
															gboolean _tmp119_;
															_tmp119_ = TRUE;
															while (TRUE) {
																gboolean _tmp120_;
																xmlAttr* _tmp123_;
																xmlAttr* _tmp124_;
																const gchar* _tmp125_;
																_tmp120_ = _tmp119_;
																if (!_tmp120_) {
																	xmlAttr* _tmp121_;
																	xmlAttr* _tmp122_;
																	_tmp121_ = prop;
																	_tmp122_ = _tmp121_->next;
																	prop = _tmp122_;
																}
																_tmp119_ = FALSE;
																_tmp123_ = prop;
																if (!(_tmp123_ != NULL)) {
																	break;
																}
																_tmp124_ = prop;
																_tmp125_ = _tmp124_->name;
																if (g_strcmp0 (_tmp125_, "value") == 0) {
																	xmlAttr* _tmp126_;
																	xmlNode* _tmp127_;
																	const gchar* _tmp128_;
																	gchar* _tmp129_;
																	_tmp126_ = prop;
																	_tmp127_ = _tmp126_->children;
																	_tmp128_ = _tmp127_->content;
																	_tmp129_ = g_strdup (_tmp128_);
																	_g_free0 (value);
																	value = _tmp129_;
																} else {
																	xmlAttr* _tmp130_;
																	const gchar* _tmp131_;
																	_tmp130_ = prop;
																	_tmp131_ = _tmp130_->name;
																	if (g_strcmp0 (_tmp131_, "target") == 0) {
																		xmlAttr* _tmp132_;
																		xmlNode* _tmp133_;
																		const gchar* _tmp134_;
																		gchar* _tmp135_;
																		_tmp132_ = prop;
																		_tmp133_ = _tmp132_->children;
																		_tmp134_ = _tmp133_->content;
																		_tmp135_ = g_strdup (_tmp134_);
																		_g_free0 (target);
																		target = _tmp135_;
																	} else {
																		xmlAttr* _tmp136_;
																		const gchar* _tmp137_;
																		_tmp136_ = prop;
																		_tmp137_ = _tmp136_->name;
																		g_warning ("dconf-schema.vala:111: Unknown property on <alias>, %s", _tmp137_);
																	}
																}
															}
														}
													}
													_tmp138_ = value;
													if (_tmp138_ == NULL) {
														g_warning ("dconf-schema.vala:116: Ignoring <alias> with no value");
														_g_free0 (target);
														_g_free0 (value);
														continue;
													}
													_tmp139_ = target;
													if (_tmp139_ == NULL) {
														g_warning ("dconf-schema.vala:121: Ignoring <alias> with no target");
														_g_free0 (target);
														_g_free0 (value);
														continue;
													}
													_tmp140_ = target;
													_tmp141_ = g_variant_new_string (_tmp140_);
													g_variant_ref_sink (_tmp141_);
													v = _tmp141_;
													_tmp142_ = value;
													_tmp143_ = v;
													_tmp144_ = schema_choice_new (_tmp142_, _tmp143_);
													self->choices = g_list_append (self->choices, _tmp144_);
													_g_variant_unref0 (v);
													_g_free0 (target);
													_g_free0 (value);
												}
											}
										}
									} else {
										gboolean _tmp145_ = FALSE;
										xmlNode* _tmp146_;
										xmlElementType _tmp147_;
										gboolean _tmp150_;
										_tmp146_ = child;
										_tmp147_ = _tmp146_->type;
										if (_tmp147_ != XML_TEXT_NODE) {
											xmlNode* _tmp148_;
											xmlElementType _tmp149_;
											_tmp148_ = child;
											_tmp149_ = _tmp148_->type;
											_tmp145_ = _tmp149_ != XML_COMMENT_NODE;
										} else {
											_tmp145_ = FALSE;
										}
										_tmp150_ = _tmp145_;
										if (_tmp150_) {
											xmlNode* _tmp151_;
											const gchar* _tmp152_;
											_tmp151_ = child;
											_tmp152_ = _tmp151_->name;
											g_warning ("dconf-schema.vala:130: Unknown child tag in <key>, <%s>", _tmp152_);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return self;
}


SchemaKey* schema_key_new_from_xml (xmlNode* node, Schema* schema, const gchar* gettext_domain) {
	return schema_key_construct_from_xml (TYPE_SCHEMA_KEY, node, schema, gettext_domain);
}


SchemaKey* schema_key_construct (GType object_type) {
	SchemaKey* self = NULL;
	self = (SchemaKey*) g_type_create_instance (object_type);
	return self;
}


SchemaKey* schema_key_new (void) {
	return schema_key_construct (TYPE_SCHEMA_KEY);
}


static void value_schema_key_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_key_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_key_unref (value->data[0].v_pointer);
	}
}


static void value_schema_key_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_key_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_key_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_key_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaKey* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_key_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_key_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaKey** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_key_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaKey* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_KEY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_key (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_KEY), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_key (GValue* value, gpointer v_object) {
	SchemaKey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_KEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_KEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_key_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_key_unref (old);
	}
}


void value_take_schema_key (GValue* value, gpointer v_object) {
	SchemaKey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_KEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_KEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_key_unref (old);
	}
}


static void schema_key_class_init (SchemaKeyClass * klass) {
	schema_key_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_KEY_CLASS (klass)->finalize = schema_key_finalize;
}


static void schema_key_instance_init (SchemaKey * self) {
	self->ref_count = 1;
}


static void schema_key_finalize (SchemaKey* obj) {
	SchemaKey * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_KEY, SchemaKey);
	_schema_unref0 (self->schema);
	_g_free0 (self->name);
	_g_free0 (self->type);
	_g_variant_unref0 (self->default_value);
	_schema_value_range_unref0 (self->range);
	_schema_value_range_unref0 (self->type_range);
	__g_list_free__schema_choice_unref0_0 (self->choices);
	_g_free0 (self->enum_name);
	_g_free0 (self->summary);
	_g_free0 (self->description);
	_g_free0 (self->gettext_domain);
}


GType schema_key_get_type (void) {
	static volatile gsize schema_key_type_id__volatile = 0;
	if (g_once_init_enter (&schema_key_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_key_init, value_schema_key_free_value, value_schema_key_copy_value, value_schema_key_peek_pointer, "p", value_schema_key_collect_value, "p", value_schema_key_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaKeyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_key_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaKey), 0, (GInstanceInitFunc) schema_key_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_key_type_id;
		schema_key_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaKey", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_key_type_id__volatile, schema_key_type_id);
	}
	return schema_key_type_id__volatile;
}


gpointer schema_key_ref (gpointer instance) {
	SchemaKey* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_key_unref (gpointer instance) {
	SchemaKey* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_KEY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SchemaValue* schema_value_construct (GType object_type, guint index, const gchar* nick, gint value) {
	SchemaValue * self = NULL;
	guint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gint _tmp3_;
	g_return_val_if_fail (nick != NULL, NULL);
	self = (SchemaValue*) g_object_new (object_type, NULL);
	_tmp0_ = index;
	self->index = _tmp0_;
	_tmp1_ = nick;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (self->nick);
	self->nick = _tmp2_;
	_tmp3_ = value;
	self->value = _tmp3_;
	return self;
}


SchemaValue* schema_value_new (guint index, const gchar* nick, gint value) {
	return schema_value_construct (TYPE_SCHEMA_VALUE, index, nick, value);
}


static void schema_value_class_init (SchemaValueClass * klass) {
	schema_value_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = schema_value_finalize;
}


static void schema_value_instance_init (SchemaValue * self) {
}


static void schema_value_finalize (GObject* obj) {
	SchemaValue * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_VALUE, SchemaValue);
	_g_free0 (self->nick);
	G_OBJECT_CLASS (schema_value_parent_class)->finalize (obj);
}


GType schema_value_get_type (void) {
	static volatile gsize schema_value_type_id__volatile = 0;
	if (g_once_init_enter (&schema_value_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SchemaValueClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_value_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaValue), 0, (GInstanceInitFunc) schema_value_instance_init, NULL };
		GType schema_value_type_id;
		schema_value_type_id = g_type_register_static (G_TYPE_OBJECT, "SchemaValue", &g_define_type_info, 0);
		g_once_init_leave (&schema_value_type_id__volatile, schema_value_type_id);
	}
	return schema_value_type_id__volatile;
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


SchemaChoice* schema_choice_construct (GType object_type, const gchar* name, GVariant* value) {
	SchemaChoice* self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GVariant* _tmp2_;
	GVariant* _tmp3_;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (value != NULL, NULL);
	self = (SchemaChoice*) g_type_create_instance (object_type);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->name);
	self->name = _tmp1_;
	_tmp2_ = value;
	_tmp3_ = _g_variant_ref0 (_tmp2_);
	_g_variant_unref0 (self->value);
	self->value = _tmp3_;
	return self;
}


SchemaChoice* schema_choice_new (const gchar* name, GVariant* value) {
	return schema_choice_construct (TYPE_SCHEMA_CHOICE, name, value);
}


static void value_schema_choice_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_choice_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_choice_unref (value->data[0].v_pointer);
	}
}


static void value_schema_choice_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_choice_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_choice_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_choice_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaChoice* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_choice_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_choice_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaChoice** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_choice_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_choice (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaChoice* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_CHOICE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_choice (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_CHOICE), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_choice (GValue* value, gpointer v_object) {
	SchemaChoice* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_CHOICE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_CHOICE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_choice_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_choice_unref (old);
	}
}


void value_take_schema_choice (GValue* value, gpointer v_object) {
	SchemaChoice* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_CHOICE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_CHOICE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_choice_unref (old);
	}
}


static void schema_choice_class_init (SchemaChoiceClass * klass) {
	schema_choice_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_CHOICE_CLASS (klass)->finalize = schema_choice_finalize;
}


static void schema_choice_instance_init (SchemaChoice * self) {
	self->ref_count = 1;
}


static void schema_choice_finalize (SchemaChoice* obj) {
	SchemaChoice * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_CHOICE, SchemaChoice);
	_g_free0 (self->name);
	_g_variant_unref0 (self->value);
}


GType schema_choice_get_type (void) {
	static volatile gsize schema_choice_type_id__volatile = 0;
	if (g_once_init_enter (&schema_choice_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_choice_init, value_schema_choice_free_value, value_schema_choice_copy_value, value_schema_choice_peek_pointer, "p", value_schema_choice_collect_value, "p", value_schema_choice_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaChoiceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_choice_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaChoice), 0, (GInstanceInitFunc) schema_choice_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_choice_type_id;
		schema_choice_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaChoice", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_choice_type_id__volatile, schema_choice_type_id);
	}
	return schema_choice_type_id__volatile;
}


gpointer schema_choice_ref (gpointer instance) {
	SchemaChoice* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_choice_unref (gpointer instance) {
	SchemaChoice* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_CHOICE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SchemaValueRange* schema_value_range_construct_from_xml (GType object_type, const gchar* type, xmlNode* node) {
	SchemaValueRange* self = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (type != NULL, NULL);
	self = (SchemaValueRange*) g_type_create_instance (object_type);
	{
		xmlNode* _tmp0_;
		xmlAttr* _tmp1_;
		xmlAttr* prop;
		_tmp0_ = node;
		_tmp1_ = _tmp0_->properties;
		prop = _tmp1_;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				xmlAttr* _tmp6_;
				xmlAttr* _tmp7_;
				const gchar* _tmp8_;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					xmlAttr* _tmp4_;
					xmlAttr* _tmp5_;
					_tmp4_ = prop;
					_tmp5_ = _tmp4_->next;
					prop = _tmp5_;
				}
				_tmp2_ = FALSE;
				_tmp6_ = prop;
				if (!(_tmp6_ != NULL)) {
					break;
				}
				_tmp7_ = prop;
				_tmp8_ = _tmp7_->name;
				if (g_strcmp0 (_tmp8_, "min") == 0) {
					{
						const gchar* _tmp9_;
						GVariantType* _tmp10_;
						GVariantType* _tmp11_;
						xmlAttr* _tmp12_;
						xmlNode* _tmp13_;
						const gchar* _tmp14_;
						GVariant* _tmp15_ = NULL;
						GVariant* _tmp16_;
						GVariant* _tmp17_;
						_tmp9_ = type;
						_tmp10_ = g_variant_type_new (_tmp9_);
						_tmp11_ = _tmp10_;
						_tmp12_ = prop;
						_tmp13_ = _tmp12_->children;
						_tmp14_ = _tmp13_->content;
						_tmp15_ = g_variant_parse (_tmp11_, _tmp14_, NULL, NULL, &_inner_error_);
						_tmp16_ = _tmp15_;
						_g_variant_type_free0 (_tmp11_);
						_tmp17_ = _tmp16_;
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
								goto __catch6_g_variant_parse_error;
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
						_g_variant_unref0 (self->min);
						self->min = _tmp17_;
					}
					goto __finally6;
					__catch6_g_variant_parse_error:
					{
						GError* e = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_g_error_free0 (e);
					}
					__finally6:
					if (_inner_error_ != NULL) {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				} else {
					xmlAttr* _tmp18_;
					const gchar* _tmp19_;
					_tmp18_ = prop;
					_tmp19_ = _tmp18_->name;
					if (g_strcmp0 (_tmp19_, "max") == 0) {
						{
							const gchar* _tmp20_;
							GVariantType* _tmp21_;
							GVariantType* _tmp22_;
							xmlAttr* _tmp23_;
							xmlNode* _tmp24_;
							const gchar* _tmp25_;
							GVariant* _tmp26_ = NULL;
							GVariant* _tmp27_;
							GVariant* _tmp28_;
							_tmp20_ = type;
							_tmp21_ = g_variant_type_new (_tmp20_);
							_tmp22_ = _tmp21_;
							_tmp23_ = prop;
							_tmp24_ = _tmp23_->children;
							_tmp25_ = _tmp24_->content;
							_tmp26_ = g_variant_parse (_tmp22_, _tmp25_, NULL, NULL, &_inner_error_);
							_tmp27_ = _tmp26_;
							_g_variant_type_free0 (_tmp22_);
							_tmp28_ = _tmp27_;
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
									goto __catch7_g_variant_parse_error;
								}
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
							_g_variant_unref0 (self->max);
							self->max = _tmp28_;
						}
						goto __finally7;
						__catch7_g_variant_parse_error:
						{
							GError* e = NULL;
							e = _inner_error_;
							_inner_error_ = NULL;
							_g_error_free0 (e);
						}
						__finally7:
						if (_inner_error_ != NULL) {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					} else {
						xmlAttr* _tmp29_;
						const gchar* _tmp30_;
						_tmp29_ = prop;
						_tmp30_ = _tmp29_->name;
						g_warning ("dconf-schema.vala:196: Unknown property in <range>, %s", _tmp30_);
					}
				}
			}
		}
	}
	return self;
}


SchemaValueRange* schema_value_range_new_from_xml (const gchar* type, xmlNode* node) {
	return schema_value_range_construct_from_xml (TYPE_SCHEMA_VALUE_RANGE, type, node);
}


SchemaValueRange* schema_value_range_construct (GType object_type) {
	SchemaValueRange* self = NULL;
	self = (SchemaValueRange*) g_type_create_instance (object_type);
	return self;
}


SchemaValueRange* schema_value_range_new (void) {
	return schema_value_range_construct (TYPE_SCHEMA_VALUE_RANGE);
}


static void value_schema_value_range_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_value_range_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_value_range_unref (value->data[0].v_pointer);
	}
}


static void value_schema_value_range_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_value_range_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_value_range_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_value_range_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaValueRange* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_value_range_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_value_range_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaValueRange** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_value_range_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_value_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaValueRange* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_VALUE_RANGE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_value_range (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_VALUE_RANGE), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_value_range (GValue* value, gpointer v_object) {
	SchemaValueRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_VALUE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_VALUE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_value_range_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_value_range_unref (old);
	}
}


void value_take_schema_value_range (GValue* value, gpointer v_object) {
	SchemaValueRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_VALUE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_VALUE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_value_range_unref (old);
	}
}


static void schema_value_range_class_init (SchemaValueRangeClass * klass) {
	schema_value_range_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_VALUE_RANGE_CLASS (klass)->finalize = schema_value_range_finalize;
}


static void schema_value_range_instance_init (SchemaValueRange * self) {
	self->ref_count = 1;
}


static void schema_value_range_finalize (SchemaValueRange* obj) {
	SchemaValueRange * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_VALUE_RANGE, SchemaValueRange);
	_g_variant_unref0 (self->min);
	_g_variant_unref0 (self->max);
}


GType schema_value_range_get_type (void) {
	static volatile gsize schema_value_range_type_id__volatile = 0;
	if (g_once_init_enter (&schema_value_range_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_value_range_init, value_schema_value_range_free_value, value_schema_value_range_copy_value, value_schema_value_range_peek_pointer, "p", value_schema_value_range_collect_value, "p", value_schema_value_range_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaValueRangeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_value_range_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaValueRange), 0, (GInstanceInitFunc) schema_value_range_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_value_range_type_id;
		schema_value_range_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaValueRange", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_value_range_type_id__volatile, schema_value_range_type_id);
	}
	return schema_value_range_type_id__volatile;
}


gpointer schema_value_range_ref (gpointer instance) {
	SchemaValueRange* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_value_range_unref (gpointer instance) {
	SchemaValueRange* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_VALUE_RANGE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gpointer _schema_list_ref0 (gpointer self) {
	return self ? schema_list_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


SchemaEnum* schema_enum_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node) {
	SchemaEnum* self = NULL;
	SchemaList* _tmp0_;
	SchemaList* _tmp1_;
	g_return_val_if_fail (list != NULL, NULL);
	self = (SchemaEnum*) g_type_create_instance (object_type);
	_tmp0_ = list;
	_tmp1_ = _schema_list_ref0 (_tmp0_);
	_schema_list_unref0 (self->list);
	self->list = _tmp1_;
	{
		xmlNode* _tmp2_;
		xmlAttr* _tmp3_;
		xmlAttr* prop;
		_tmp2_ = node;
		_tmp3_ = _tmp2_->properties;
		prop = _tmp3_;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				xmlAttr* _tmp8_;
				xmlAttr* _tmp9_;
				const gchar* _tmp10_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					xmlAttr* _tmp6_;
					xmlAttr* _tmp7_;
					_tmp6_ = prop;
					_tmp7_ = _tmp6_->next;
					prop = _tmp7_;
				}
				_tmp4_ = FALSE;
				_tmp8_ = prop;
				if (!(_tmp8_ != NULL)) {
					break;
				}
				_tmp9_ = prop;
				_tmp10_ = _tmp9_->name;
				if (g_strcmp0 (_tmp10_, "id") == 0) {
					xmlAttr* _tmp11_;
					xmlNode* _tmp12_;
					const gchar* _tmp13_;
					gchar* _tmp14_;
					_tmp11_ = prop;
					_tmp12_ = _tmp11_->children;
					_tmp13_ = _tmp12_->content;
					_tmp14_ = g_strdup (_tmp13_);
					_g_free0 (self->id);
					self->id = _tmp14_;
				} else {
					xmlAttr* _tmp15_;
					const gchar* _tmp16_;
					_tmp15_ = prop;
					_tmp16_ = _tmp15_->name;
					g_warning ("dconf-schema.vala:219: Unknown property in <enum>, %s", _tmp16_);
				}
			}
		}
	}
	{
		xmlNode* _tmp17_;
		xmlNode* _tmp18_;
		xmlNode* child;
		_tmp17_ = node;
		_tmp18_ = _tmp17_->children;
		child = _tmp18_;
		{
			gboolean _tmp19_;
			_tmp19_ = TRUE;
			while (TRUE) {
				gboolean _tmp20_;
				xmlNode* _tmp23_;
				xmlNode* _tmp24_;
				const gchar* _tmp25_;
				_tmp20_ = _tmp19_;
				if (!_tmp20_) {
					xmlNode* _tmp21_;
					xmlNode* _tmp22_;
					_tmp21_ = child;
					_tmp22_ = _tmp21_->next;
					child = _tmp22_;
				}
				_tmp19_ = FALSE;
				_tmp23_ = child;
				if (!(_tmp23_ != NULL)) {
					break;
				}
				_tmp24_ = child;
				_tmp25_ = _tmp24_->name;
				if (g_strcmp0 (_tmp25_, "value") == 0) {
					gchar* nick;
					gint value;
					GList* _tmp47_;
					guint _tmp48_ = 0U;
					const gchar* _tmp49_;
					gint _tmp50_;
					SchemaValue* _tmp51_;
					SchemaValue* schema_value;
					SchemaValue* _tmp52_;
					SchemaValue* _tmp53_;
					nick = NULL;
					value = -1;
					{
						xmlNode* _tmp26_;
						xmlAttr* _tmp27_;
						xmlAttr* prop;
						_tmp26_ = child;
						_tmp27_ = _tmp26_->properties;
						prop = _tmp27_;
						{
							gboolean _tmp28_;
							_tmp28_ = TRUE;
							while (TRUE) {
								gboolean _tmp29_;
								xmlAttr* _tmp32_;
								xmlAttr* _tmp33_;
								const gchar* _tmp34_;
								_tmp29_ = _tmp28_;
								if (!_tmp29_) {
									xmlAttr* _tmp30_;
									xmlAttr* _tmp31_;
									_tmp30_ = prop;
									_tmp31_ = _tmp30_->next;
									prop = _tmp31_;
								}
								_tmp28_ = FALSE;
								_tmp32_ = prop;
								if (!(_tmp32_ != NULL)) {
									break;
								}
								_tmp33_ = prop;
								_tmp34_ = _tmp33_->name;
								if (g_strcmp0 (_tmp34_, "value") == 0) {
									xmlAttr* _tmp35_;
									xmlNode* _tmp36_;
									const gchar* _tmp37_;
									gint _tmp38_ = 0;
									_tmp35_ = prop;
									_tmp36_ = _tmp35_->children;
									_tmp37_ = _tmp36_->content;
									_tmp38_ = atoi (_tmp37_);
									value = _tmp38_;
								} else {
									xmlAttr* _tmp39_;
									const gchar* _tmp40_;
									_tmp39_ = prop;
									_tmp40_ = _tmp39_->name;
									if (g_strcmp0 (_tmp40_, "nick") == 0) {
										xmlAttr* _tmp41_;
										xmlNode* _tmp42_;
										const gchar* _tmp43_;
										gchar* _tmp44_;
										_tmp41_ = prop;
										_tmp42_ = _tmp41_->children;
										_tmp43_ = _tmp42_->content;
										_tmp44_ = g_strdup (_tmp43_);
										_g_free0 (nick);
										nick = _tmp44_;
									} else {
										xmlAttr* _tmp45_;
										const gchar* _tmp46_;
										_tmp45_ = prop;
										_tmp46_ = _tmp45_->name;
										g_warning ("dconf-schema.vala:239: Unknown property in enum <value>, %s", _tmp46_);
									}
								}
							}
						}
					}
					_tmp47_ = self->values;
					_tmp48_ = g_list_length (_tmp47_);
					_tmp49_ = nick;
					_tmp50_ = value;
					_tmp51_ = schema_value_new (_tmp48_, _tmp49_, _tmp50_);
					schema_value = _tmp51_;
					_tmp52_ = schema_value;
					_tmp53_ = _g_object_ref0 (_tmp52_);
					self->values = g_list_append (self->values, _tmp53_);
					_g_object_unref0 (schema_value);
					_g_free0 (nick);
				} else {
					gboolean _tmp54_ = FALSE;
					xmlNode* _tmp55_;
					xmlElementType _tmp56_;
					gboolean _tmp59_;
					_tmp55_ = child;
					_tmp56_ = _tmp55_->type;
					if (_tmp56_ != XML_TEXT_NODE) {
						xmlNode* _tmp57_;
						xmlElementType _tmp58_;
						_tmp57_ = child;
						_tmp58_ = _tmp57_->type;
						_tmp54_ = _tmp58_ != XML_COMMENT_NODE;
					} else {
						_tmp54_ = FALSE;
					}
					_tmp59_ = _tmp54_;
					if (_tmp59_) {
						xmlNode* _tmp60_;
						const gchar* _tmp61_;
						_tmp60_ = child;
						_tmp61_ = _tmp60_->name;
						g_warning ("dconf-schema.vala:249: Unknown tag in <enum>, <%s>", _tmp61_);
					}
				}
			}
		}
	}
	return self;
}


SchemaEnum* schema_enum_new_from_xml (SchemaList* list, xmlNode* node) {
	return schema_enum_construct_from_xml (TYPE_SCHEMA_ENUM, list, node);
}


SchemaEnum* schema_enum_construct (GType object_type) {
	SchemaEnum* self = NULL;
	self = (SchemaEnum*) g_type_create_instance (object_type);
	return self;
}


SchemaEnum* schema_enum_new (void) {
	return schema_enum_construct (TYPE_SCHEMA_ENUM);
}


static void value_schema_enum_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_enum_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_enum_unref (value->data[0].v_pointer);
	}
}


static void value_schema_enum_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_enum_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_enum_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_enum_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaEnum* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_enum_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_enum_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaEnum** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_enum_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_enum (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaEnum* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_ENUM), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_enum (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_ENUM), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_enum (GValue* value, gpointer v_object) {
	SchemaEnum* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_ENUM));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_ENUM));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_enum_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_enum_unref (old);
	}
}


void value_take_schema_enum (GValue* value, gpointer v_object) {
	SchemaEnum* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_ENUM));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_ENUM));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_enum_unref (old);
	}
}


static void schema_enum_class_init (SchemaEnumClass * klass) {
	schema_enum_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_ENUM_CLASS (klass)->finalize = schema_enum_finalize;
}


static void schema_enum_instance_init (SchemaEnum * self) {
	self->values = NULL;
	self->ref_count = 1;
}


static void schema_enum_finalize (SchemaEnum* obj) {
	SchemaEnum * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_ENUM, SchemaEnum);
	_schema_list_unref0 (self->list);
	_g_free0 (self->id);
	__g_list_free__g_object_unref0_0 (self->values);
}


GType schema_enum_get_type (void) {
	static volatile gsize schema_enum_type_id__volatile = 0;
	if (g_once_init_enter (&schema_enum_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_enum_init, value_schema_enum_free_value, value_schema_enum_copy_value, value_schema_enum_peek_pointer, "p", value_schema_enum_collect_value, "p", value_schema_enum_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaEnumClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_enum_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaEnum), 0, (GInstanceInitFunc) schema_enum_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_enum_type_id;
		schema_enum_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaEnum", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_enum_type_id__volatile, schema_enum_type_id);
	}
	return schema_enum_type_id__volatile;
}


gpointer schema_enum_ref (gpointer instance) {
	SchemaEnum* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_enum_unref (gpointer instance) {
	SchemaEnum* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_ENUM_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SchemaFlags* schema_flags_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node) {
	SchemaFlags* self = NULL;
	SchemaList* _tmp0_;
	SchemaList* _tmp1_;
	g_return_val_if_fail (list != NULL, NULL);
	self = (SchemaFlags*) g_type_create_instance (object_type);
	_tmp0_ = list;
	_tmp1_ = _schema_list_ref0 (_tmp0_);
	_schema_list_unref0 (self->list);
	self->list = _tmp1_;
	{
		xmlNode* _tmp2_;
		xmlAttr* _tmp3_;
		xmlAttr* prop;
		_tmp2_ = node;
		_tmp3_ = _tmp2_->properties;
		prop = _tmp3_;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				xmlAttr* _tmp8_;
				xmlAttr* _tmp9_;
				const gchar* _tmp10_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					xmlAttr* _tmp6_;
					xmlAttr* _tmp7_;
					_tmp6_ = prop;
					_tmp7_ = _tmp6_->next;
					prop = _tmp7_;
				}
				_tmp4_ = FALSE;
				_tmp8_ = prop;
				if (!(_tmp8_ != NULL)) {
					break;
				}
				_tmp9_ = prop;
				_tmp10_ = _tmp9_->name;
				if (g_strcmp0 (_tmp10_, "id") == 0) {
					xmlAttr* _tmp11_;
					xmlNode* _tmp12_;
					const gchar* _tmp13_;
					gchar* _tmp14_;
					_tmp11_ = prop;
					_tmp12_ = _tmp11_->children;
					_tmp13_ = _tmp12_->content;
					_tmp14_ = g_strdup (_tmp13_);
					_g_free0 (self->id);
					self->id = _tmp14_;
				} else {
					xmlAttr* _tmp15_;
					const gchar* _tmp16_;
					_tmp15_ = prop;
					_tmp16_ = _tmp15_->name;
					g_warning ("dconf-schema.vala:272: Unknown property in <flags>, %s", _tmp16_);
				}
			}
		}
	}
	{
		xmlNode* _tmp17_;
		xmlNode* _tmp18_;
		xmlNode* child;
		_tmp17_ = node;
		_tmp18_ = _tmp17_->children;
		child = _tmp18_;
		{
			gboolean _tmp19_;
			_tmp19_ = TRUE;
			while (TRUE) {
				gboolean _tmp20_;
				xmlNode* _tmp23_;
				xmlNode* _tmp24_;
				const gchar* _tmp25_;
				_tmp20_ = _tmp19_;
				if (!_tmp20_) {
					xmlNode* _tmp21_;
					xmlNode* _tmp22_;
					_tmp21_ = child;
					_tmp22_ = _tmp21_->next;
					child = _tmp22_;
				}
				_tmp19_ = FALSE;
				_tmp23_ = child;
				if (!(_tmp23_ != NULL)) {
					break;
				}
				_tmp24_ = child;
				_tmp25_ = _tmp24_->name;
				if (g_strcmp0 (_tmp25_, "value") == 0) {
					gchar* nick;
					gint value;
					GList* _tmp47_;
					guint _tmp48_ = 0U;
					const gchar* _tmp49_;
					gint _tmp50_;
					SchemaValue* _tmp51_;
					SchemaValue* schema_value;
					SchemaValue* _tmp52_;
					SchemaValue* _tmp53_;
					nick = NULL;
					value = -1;
					{
						xmlNode* _tmp26_;
						xmlAttr* _tmp27_;
						xmlAttr* prop;
						_tmp26_ = child;
						_tmp27_ = _tmp26_->properties;
						prop = _tmp27_;
						{
							gboolean _tmp28_;
							_tmp28_ = TRUE;
							while (TRUE) {
								gboolean _tmp29_;
								xmlAttr* _tmp32_;
								xmlAttr* _tmp33_;
								const gchar* _tmp34_;
								_tmp29_ = _tmp28_;
								if (!_tmp29_) {
									xmlAttr* _tmp30_;
									xmlAttr* _tmp31_;
									_tmp30_ = prop;
									_tmp31_ = _tmp30_->next;
									prop = _tmp31_;
								}
								_tmp28_ = FALSE;
								_tmp32_ = prop;
								if (!(_tmp32_ != NULL)) {
									break;
								}
								_tmp33_ = prop;
								_tmp34_ = _tmp33_->name;
								if (g_strcmp0 (_tmp34_, "value") == 0) {
									xmlAttr* _tmp35_;
									xmlNode* _tmp36_;
									const gchar* _tmp37_;
									gint _tmp38_ = 0;
									_tmp35_ = prop;
									_tmp36_ = _tmp35_->children;
									_tmp37_ = _tmp36_->content;
									_tmp38_ = atoi (_tmp37_);
									value = _tmp38_;
								} else {
									xmlAttr* _tmp39_;
									const gchar* _tmp40_;
									_tmp39_ = prop;
									_tmp40_ = _tmp39_->name;
									if (g_strcmp0 (_tmp40_, "nick") == 0) {
										xmlAttr* _tmp41_;
										xmlNode* _tmp42_;
										const gchar* _tmp43_;
										gchar* _tmp44_;
										_tmp41_ = prop;
										_tmp42_ = _tmp41_->children;
										_tmp43_ = _tmp42_->content;
										_tmp44_ = g_strdup (_tmp43_);
										_g_free0 (nick);
										nick = _tmp44_;
									} else {
										xmlAttr* _tmp45_;
										const gchar* _tmp46_;
										_tmp45_ = prop;
										_tmp46_ = _tmp45_->name;
										g_warning ("dconf-schema.vala:292: Unknown property in flags <value>, %s", _tmp46_);
									}
								}
							}
						}
					}
					_tmp47_ = self->values;
					_tmp48_ = g_list_length (_tmp47_);
					_tmp49_ = nick;
					_tmp50_ = value;
					_tmp51_ = schema_value_new (_tmp48_, _tmp49_, _tmp50_);
					schema_value = _tmp51_;
					_tmp52_ = schema_value;
					_tmp53_ = _g_object_ref0 (_tmp52_);
					self->values = g_list_append (self->values, _tmp53_);
					_g_object_unref0 (schema_value);
					_g_free0 (nick);
				} else {
					gboolean _tmp54_ = FALSE;
					xmlNode* _tmp55_;
					xmlElementType _tmp56_;
					gboolean _tmp59_;
					_tmp55_ = child;
					_tmp56_ = _tmp55_->type;
					if (_tmp56_ != XML_TEXT_NODE) {
						xmlNode* _tmp57_;
						xmlElementType _tmp58_;
						_tmp57_ = child;
						_tmp58_ = _tmp57_->type;
						_tmp54_ = _tmp58_ != XML_COMMENT_NODE;
					} else {
						_tmp54_ = FALSE;
					}
					_tmp59_ = _tmp54_;
					if (_tmp59_) {
						xmlNode* _tmp60_;
						const gchar* _tmp61_;
						_tmp60_ = child;
						_tmp61_ = _tmp60_->name;
						g_warning ("dconf-schema.vala:302: Unknown tag in <flags>, <%s>", _tmp61_);
					}
				}
			}
		}
	}
	return self;
}


SchemaFlags* schema_flags_new_from_xml (SchemaList* list, xmlNode* node) {
	return schema_flags_construct_from_xml (TYPE_SCHEMA_FLAGS, list, node);
}


SchemaFlags* schema_flags_construct (GType object_type) {
	SchemaFlags* self = NULL;
	self = (SchemaFlags*) g_type_create_instance (object_type);
	return self;
}


SchemaFlags* schema_flags_new (void) {
	return schema_flags_construct (TYPE_SCHEMA_FLAGS);
}


static void value_schema_flags_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_flags_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_flags_unref (value->data[0].v_pointer);
	}
}


static void value_schema_flags_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_flags_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_flags_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_flags_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaFlags* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_flags_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_flags_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaFlags** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_flags_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_flags (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaFlags* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_FLAGS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_flags (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_FLAGS), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_flags (GValue* value, gpointer v_object) {
	SchemaFlags* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_FLAGS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_FLAGS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_flags_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_flags_unref (old);
	}
}


void value_take_schema_flags (GValue* value, gpointer v_object) {
	SchemaFlags* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_FLAGS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_FLAGS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_flags_unref (old);
	}
}


static void schema_flags_class_init (SchemaFlagsClass * klass) {
	schema_flags_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_FLAGS_CLASS (klass)->finalize = schema_flags_finalize;
}


static void schema_flags_instance_init (SchemaFlags * self) {
	self->values = NULL;
	self->ref_count = 1;
}


static void schema_flags_finalize (SchemaFlags* obj) {
	SchemaFlags * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_FLAGS, SchemaFlags);
	_schema_list_unref0 (self->list);
	_g_free0 (self->id);
	__g_list_free__g_object_unref0_0 (self->values);
}


GType schema_flags_get_type (void) {
	static volatile gsize schema_flags_type_id__volatile = 0;
	if (g_once_init_enter (&schema_flags_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_flags_init, value_schema_flags_free_value, value_schema_flags_copy_value, value_schema_flags_peek_pointer, "p", value_schema_flags_collect_value, "p", value_schema_flags_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaFlagsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_flags_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaFlags), 0, (GInstanceInitFunc) schema_flags_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_flags_type_id;
		schema_flags_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaFlags", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_flags_type_id__volatile, schema_flags_type_id);
	}
	return schema_flags_type_id__volatile;
}


gpointer schema_flags_ref (gpointer instance) {
	SchemaFlags* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_flags_unref (gpointer instance) {
	SchemaFlags* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_FLAGS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _schema_key_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_key_unref (var), NULL));
}


static gpointer _schema_key_ref0 (gpointer self) {
	return self ? schema_key_ref (self) : NULL;
}


Schema* schema_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node, const gchar* gettext_domain) {
	Schema* self = NULL;
	SchemaList* _tmp0_;
	SchemaList* _tmp1_;
	g_return_val_if_fail (list != NULL, NULL);
	self = (Schema*) g_type_create_instance (object_type);
	_tmp0_ = list;
	_tmp1_ = _schema_list_ref0 (_tmp0_);
	_schema_list_unref0 (self->list);
	self->list = _tmp1_;
	{
		xmlNode* _tmp2_;
		xmlAttr* _tmp3_;
		xmlAttr* prop;
		_tmp2_ = node;
		_tmp3_ = _tmp2_->properties;
		prop = _tmp3_;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				gboolean _tmp5_;
				xmlAttr* _tmp8_;
				xmlAttr* _tmp9_;
				const gchar* _tmp10_;
				_tmp5_ = _tmp4_;
				if (!_tmp5_) {
					xmlAttr* _tmp6_;
					xmlAttr* _tmp7_;
					_tmp6_ = prop;
					_tmp7_ = _tmp6_->next;
					prop = _tmp7_;
				}
				_tmp4_ = FALSE;
				_tmp8_ = prop;
				if (!(_tmp8_ != NULL)) {
					break;
				}
				_tmp9_ = prop;
				_tmp10_ = _tmp9_->name;
				if (g_strcmp0 (_tmp10_, "id") == 0) {
					xmlAttr* _tmp11_;
					xmlNode* _tmp12_;
					const gchar* _tmp13_;
					gchar* _tmp14_;
					_tmp11_ = prop;
					_tmp12_ = _tmp11_->children;
					_tmp13_ = _tmp12_->content;
					_tmp14_ = g_strdup (_tmp13_);
					_g_free0 (self->id);
					self->id = _tmp14_;
				} else {
					xmlAttr* _tmp15_;
					const gchar* _tmp16_;
					_tmp15_ = prop;
					_tmp16_ = _tmp15_->name;
					if (g_strcmp0 (_tmp16_, "path") == 0) {
						xmlAttr* _tmp17_;
						xmlNode* _tmp18_;
						const gchar* _tmp19_;
						gchar* _tmp20_;
						_tmp17_ = prop;
						_tmp18_ = _tmp17_->children;
						_tmp19_ = _tmp18_->content;
						_tmp20_ = g_strdup (_tmp19_);
						_g_free0 (self->path);
						self->path = _tmp20_;
					} else {
						xmlAttr* _tmp21_;
						const gchar* _tmp22_;
						_tmp21_ = prop;
						_tmp22_ = _tmp21_->name;
						if (g_strcmp0 (_tmp22_, "gettext-domain") == 0) {
							xmlAttr* _tmp23_;
							xmlNode* _tmp24_;
							const gchar* _tmp25_;
							_tmp23_ = prop;
							_tmp24_ = _tmp23_->children;
							_tmp25_ = _tmp24_->content;
							gettext_domain = _tmp25_;
						} else {
							xmlAttr* _tmp26_;
							const gchar* _tmp27_;
							_tmp26_ = prop;
							_tmp27_ = _tmp26_->name;
							g_warning ("dconf-schema.vala:330: Unknown property on <schema>, %s", _tmp27_);
						}
					}
				}
			}
		}
	}
	{
		xmlNode* _tmp28_;
		xmlNode* _tmp29_;
		xmlNode* child;
		_tmp28_ = node;
		_tmp29_ = _tmp28_->children;
		child = _tmp29_;
		{
			gboolean _tmp30_;
			_tmp30_ = TRUE;
			while (TRUE) {
				gboolean _tmp31_;
				xmlNode* _tmp34_;
				xmlNode* _tmp35_;
				const gchar* _tmp36_;
				xmlNode* _tmp37_;
				const gchar* _tmp38_;
				SchemaKey* _tmp39_;
				SchemaKey* key;
				GHashTable* _tmp40_;
				SchemaKey* _tmp41_;
				const gchar* _tmp42_;
				gchar* _tmp43_;
				SchemaKey* _tmp44_;
				SchemaKey* _tmp45_;
				_tmp31_ = _tmp30_;
				if (!_tmp31_) {
					xmlNode* _tmp32_;
					xmlNode* _tmp33_;
					_tmp32_ = child;
					_tmp33_ = _tmp32_->next;
					child = _tmp33_;
				}
				_tmp30_ = FALSE;
				_tmp34_ = child;
				if (!(_tmp34_ != NULL)) {
					break;
				}
				_tmp35_ = child;
				_tmp36_ = _tmp35_->name;
				if (g_strcmp0 (_tmp36_, "key") != 0) {
					continue;
				}
				_tmp37_ = child;
				_tmp38_ = gettext_domain;
				_tmp39_ = schema_key_new_from_xml (_tmp37_, self, _tmp38_);
				key = _tmp39_;
				_tmp40_ = self->keys;
				_tmp41_ = key;
				_tmp42_ = _tmp41_->name;
				_tmp43_ = g_strdup (_tmp42_);
				_tmp44_ = key;
				_tmp45_ = _schema_key_ref0 (_tmp44_);
				g_hash_table_insert (_tmp40_, _tmp43_, _tmp45_);
				_schema_key_unref0 (key);
			}
		}
	}
	return self;
}


Schema* schema_new_from_xml (SchemaList* list, xmlNode* node, const gchar* gettext_domain) {
	return schema_construct_from_xml (TYPE_SCHEMA, list, node, gettext_domain);
}


Schema* schema_construct (GType object_type) {
	Schema* self = NULL;
	self = (Schema*) g_type_create_instance (object_type);
	return self;
}


Schema* schema_new (void) {
	return schema_construct (TYPE_SCHEMA);
}


static void value_schema_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_unref (value->data[0].v_pointer);
	}
}


static void value_schema_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Schema* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Schema** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchema* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema (GValue* value, gpointer v_object) {
	Schema* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_unref (old);
	}
}


void value_take_schema (GValue* value, gpointer v_object) {
	Schema* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_unref (old);
	}
}


static void schema_class_init (SchemaClass * klass) {
	schema_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_CLASS (klass)->finalize = schema_finalize;
}


static void schema_instance_init (Schema * self) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _schema_key_unref0_);
	self->keys = _tmp2_;
	self->ref_count = 1;
}


static void schema_finalize (Schema* obj) {
	Schema * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA, Schema);
	_schema_list_unref0 (self->list);
	_g_free0 (self->id);
	_g_free0 (self->path);
	_g_hash_table_unref0 (self->keys);
}


GType schema_get_type (void) {
	static volatile gsize schema_type_id__volatile = 0;
	if (g_once_init_enter (&schema_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_init, value_schema_free_value, value_schema_copy_value, value_schema_peek_pointer, "p", value_schema_collect_value, "p", value_schema_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Schema), 0, (GInstanceInitFunc) schema_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_type_id;
		schema_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Schema", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_type_id__volatile, schema_type_id);
	}
	return schema_type_id__volatile;
}


gpointer schema_ref (gpointer instance) {
	Schema* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_unref (gpointer instance) {
	Schema* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _schema_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_unref (var), NULL));
}


static void _schema_enum_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_enum_unref (var), NULL));
}


static void _schema_flags_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_flags_unref (var), NULL));
}


static gpointer _schema_enum_ref0 (gpointer self) {
	return self ? schema_enum_ref (self) : NULL;
}


static gpointer _schema_flags_ref0 (gpointer self) {
	return self ? schema_flags_ref (self) : NULL;
}


void schema_list_parse_file (SchemaList* self, const gchar* path) {
	const gchar* _tmp0_;
	xmlDoc* _tmp1_ = NULL;
	xmlDoc* doc;
	xmlDoc* _tmp2_;
	xmlDoc* _tmp3_;
	xmlNode* _tmp4_ = NULL;
	xmlNode* root;
	xmlNode* _tmp5_;
	xmlNode* _tmp6_;
	const gchar* _tmp7_;
	gchar* gettext_domain;
	xmlDoc* _tmp80_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	_tmp1_ = xmlParseFile (_tmp0_);
	doc = _tmp1_;
	_tmp2_ = doc;
	if (_tmp2_ == NULL) {
		return;
	}
	_tmp3_ = doc;
	_tmp4_ = xmlDocGetRootElement (_tmp3_);
	root = _tmp4_;
	_tmp5_ = root;
	if (_tmp5_ == NULL) {
		return;
	}
	_tmp6_ = root;
	_tmp7_ = _tmp6_->name;
	if (g_strcmp0 (_tmp7_, "schemalist") != 0) {
		return;
	}
	gettext_domain = NULL;
	{
		xmlNode* _tmp8_;
		xmlAttr* _tmp9_;
		xmlAttr* prop;
		_tmp8_ = root;
		_tmp9_ = _tmp8_->properties;
		prop = _tmp9_;
		{
			gboolean _tmp10_;
			_tmp10_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_;
				xmlAttr* _tmp14_;
				xmlAttr* _tmp15_;
				const gchar* _tmp16_;
				_tmp11_ = _tmp10_;
				if (!_tmp11_) {
					xmlAttr* _tmp12_;
					xmlAttr* _tmp13_;
					_tmp12_ = prop;
					_tmp13_ = _tmp12_->next;
					prop = _tmp13_;
				}
				_tmp10_ = FALSE;
				_tmp14_ = prop;
				if (!(_tmp14_ != NULL)) {
					break;
				}
				_tmp15_ = prop;
				_tmp16_ = _tmp15_->name;
				if (g_strcmp0 (_tmp16_, "gettext-domain") == 0) {
					xmlAttr* _tmp17_;
					xmlNode* _tmp18_;
					const gchar* _tmp19_;
					gchar* _tmp20_;
					_tmp17_ = prop;
					_tmp18_ = _tmp17_->children;
					_tmp19_ = _tmp18_->content;
					_tmp20_ = g_strdup (_tmp19_);
					_g_free0 (gettext_domain);
					gettext_domain = _tmp20_;
				}
			}
		}
	}
	{
		xmlNode* _tmp21_;
		xmlNode* _tmp22_;
		xmlNode* node;
		_tmp21_ = root;
		_tmp22_ = _tmp21_->children;
		node = _tmp22_;
		{
			gboolean _tmp23_;
			_tmp23_ = TRUE;
			while (TRUE) {
				gboolean _tmp24_;
				xmlNode* _tmp27_;
				xmlNode* _tmp28_;
				const gchar* _tmp29_;
				_tmp24_ = _tmp23_;
				if (!_tmp24_) {
					xmlNode* _tmp25_;
					xmlNode* _tmp26_;
					_tmp25_ = node;
					_tmp26_ = _tmp25_->next;
					node = _tmp26_;
				}
				_tmp23_ = FALSE;
				_tmp27_ = node;
				if (!(_tmp27_ != NULL)) {
					break;
				}
				_tmp28_ = node;
				_tmp29_ = _tmp28_->name;
				if (g_strcmp0 (_tmp29_, "schema") == 0) {
					xmlNode* _tmp30_;
					const gchar* _tmp31_;
					Schema* _tmp32_;
					Schema* schema;
					Schema* _tmp33_;
					const gchar* _tmp34_;
					Schema* _tmp35_;
					GHashTable* _tmp36_;
					GList* _tmp37_ = NULL;
					GHashTable* _tmp48_;
					Schema* _tmp49_;
					const gchar* _tmp50_;
					gchar* _tmp51_;
					Schema* _tmp52_;
					Schema* _tmp53_;
					_tmp30_ = node;
					_tmp31_ = gettext_domain;
					_tmp32_ = schema_new_from_xml (self, _tmp30_, _tmp31_);
					schema = _tmp32_;
					_tmp33_ = schema;
					_tmp34_ = _tmp33_->path;
					if (_tmp34_ == NULL) {
						_schema_unref0 (schema);
						continue;
					}
					_tmp35_ = schema;
					_tmp36_ = _tmp35_->keys;
					_tmp37_ = g_hash_table_get_values (_tmp36_);
					{
						GList* key_collection = NULL;
						GList* key_it = NULL;
						key_collection = _tmp37_;
						for (key_it = key_collection; key_it != NULL; key_it = key_it->next) {
							SchemaKey* key = NULL;
							key = (SchemaKey*) key_it->data;
							{
								Schema* _tmp38_;
								const gchar* _tmp39_;
								SchemaKey* _tmp40_;
								const gchar* _tmp41_;
								gchar* _tmp42_;
								gchar* full_name;
								GHashTable* _tmp43_;
								const gchar* _tmp44_;
								gchar* _tmp45_;
								SchemaKey* _tmp46_;
								SchemaKey* _tmp47_;
								_tmp38_ = schema;
								_tmp39_ = _tmp38_->path;
								_tmp40_ = key;
								_tmp41_ = _tmp40_->name;
								_tmp42_ = g_strconcat (_tmp39_, _tmp41_, NULL);
								full_name = _tmp42_;
								_tmp43_ = self->keys;
								_tmp44_ = full_name;
								_tmp45_ = g_strdup (_tmp44_);
								_tmp46_ = key;
								_tmp47_ = _schema_key_ref0 (_tmp46_);
								g_hash_table_insert (_tmp43_, _tmp45_, _tmp47_);
								_g_free0 (full_name);
							}
						}
						_g_list_free0 (key_collection);
					}
					_tmp48_ = self->schemas;
					_tmp49_ = schema;
					_tmp50_ = _tmp49_->id;
					_tmp51_ = g_strdup (_tmp50_);
					_tmp52_ = schema;
					_tmp53_ = _schema_ref0 (_tmp52_);
					g_hash_table_insert (_tmp48_, _tmp51_, _tmp53_);
					_schema_unref0 (schema);
				} else {
					xmlNode* _tmp54_;
					const gchar* _tmp55_;
					_tmp54_ = node;
					_tmp55_ = _tmp54_->name;
					if (g_strcmp0 (_tmp55_, "enum") == 0) {
						xmlNode* _tmp56_;
						SchemaEnum* _tmp57_;
						SchemaEnum* _enum_;
						GHashTable* _tmp58_;
						SchemaEnum* _tmp59_;
						const gchar* _tmp60_;
						gchar* _tmp61_;
						SchemaEnum* _tmp62_;
						SchemaEnum* _tmp63_;
						_tmp56_ = node;
						_tmp57_ = schema_enum_new_from_xml (self, _tmp56_);
						_enum_ = _tmp57_;
						_tmp58_ = self->enums;
						_tmp59_ = _enum_;
						_tmp60_ = _tmp59_->id;
						_tmp61_ = g_strdup (_tmp60_);
						_tmp62_ = _enum_;
						_tmp63_ = _schema_enum_ref0 (_tmp62_);
						g_hash_table_insert (_tmp58_, _tmp61_, _tmp63_);
						_schema_enum_unref0 (_enum_);
					} else {
						xmlNode* _tmp64_;
						const gchar* _tmp65_;
						_tmp64_ = node;
						_tmp65_ = _tmp64_->name;
						if (g_strcmp0 (_tmp65_, "flags") == 0) {
							xmlNode* _tmp66_;
							SchemaFlags* _tmp67_;
							SchemaFlags* f;
							GHashTable* _tmp68_;
							SchemaFlags* _tmp69_;
							const gchar* _tmp70_;
							gchar* _tmp71_;
							SchemaFlags* _tmp72_;
							SchemaFlags* _tmp73_;
							_tmp66_ = node;
							_tmp67_ = schema_flags_new_from_xml (self, _tmp66_);
							f = _tmp67_;
							_tmp68_ = self->flags;
							_tmp69_ = f;
							_tmp70_ = _tmp69_->id;
							_tmp71_ = g_strdup (_tmp70_);
							_tmp72_ = f;
							_tmp73_ = _schema_flags_ref0 (_tmp72_);
							g_hash_table_insert (_tmp68_, _tmp71_, _tmp73_);
							_schema_flags_unref0 (f);
						} else {
							xmlNode* _tmp74_;
							xmlElementType _tmp75_;
							_tmp74_ = node;
							_tmp75_ = _tmp74_->type;
							if (_tmp75_ == XML_COMMENT_NODE) {
							} else {
								xmlNode* _tmp76_;
								xmlElementType _tmp77_;
								_tmp76_ = node;
								_tmp77_ = _tmp76_->type;
								if (_tmp77_ != XML_TEXT_NODE) {
									xmlNode* _tmp78_;
									const gchar* _tmp79_;
									_tmp78_ = node;
									_tmp79_ = _tmp78_->name;
									g_warning ("dconf-schema.vala:404: Unknown tag <%s>", _tmp79_);
								}
							}
						}
					}
				}
			}
		}
	}
	_tmp80_ = doc;
	xmlFreeDoc (_tmp80_);
	_g_free0 (gettext_domain);
}


void schema_list_parse_override (SchemaList* self, const gchar* path) {
	GKeyFile* _tmp0_;
	GKeyFile* keyfile;
	GKeyFile* _tmp6_;
	gsize _tmp7_;
	gchar** _tmp8_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = g_key_file_new ();
	keyfile = _tmp0_;
	{
		GKeyFile* _tmp1_;
		const gchar* _tmp2_;
		_tmp1_ = keyfile;
		_tmp2_ = path;
		g_key_file_load_from_file (_tmp1_, _tmp2_, G_KEY_FILE_NONE, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch8_g_error;
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp3_;
		GError* _tmp4_;
		const gchar* _tmp5_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = path;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("dconf-schema.vala:419: Failed to load override file %s: %s", _tmp3_, _tmp5_);
		_g_error_free0 (e);
		_g_key_file_free0 (keyfile);
		return;
	}
	__finally8:
	if (_inner_error_ != NULL) {
		_g_key_file_free0 (keyfile);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp6_ = keyfile;
	_tmp8_ = g_key_file_get_groups (_tmp6_, &_tmp7_);
	{
		gchar** group_collection = NULL;
		gint group_collection_length1 = 0;
		gint _group_collection_size_ = 0;
		gint group_it = 0;
		group_collection = _tmp8_;
		group_collection_length1 = _tmp7_;
		for (group_it = 0; group_it < _tmp7_; group_it = group_it + 1) {
			gchar* _tmp9_;
			gchar* group = NULL;
			_tmp9_ = g_strdup (group_collection[group_it]);
			group = _tmp9_;
			{
				GHashTable* _tmp10_;
				const gchar* _tmp11_;
				gconstpointer _tmp12_ = NULL;
				Schema* _tmp13_;
				Schema* schema;
				Schema* _tmp14_;
				gchar** keys = NULL;
				gint keys_length1 = 0;
				gint _keys_size_ = 0;
				gchar** _tmp20_;
				gint _tmp20__length1;
				_tmp10_ = self->schemas;
				_tmp11_ = group;
				_tmp12_ = g_hash_table_lookup (_tmp10_, _tmp11_);
				_tmp13_ = _schema_ref0 ((Schema*) _tmp12_);
				schema = _tmp13_;
				_tmp14_ = schema;
				if (_tmp14_ == NULL) {
					_schema_unref0 (schema);
					_g_free0 (group);
					continue;
				}
				{
					GKeyFile* _tmp15_;
					const gchar* _tmp16_;
					gsize _tmp17_;
					gchar** _tmp18_ = NULL;
					gchar** _tmp19_;
					gint _tmp19__length1;
					gint __tmp19__size_;
					_tmp15_ = keyfile;
					_tmp16_ = group;
					_tmp18_ = g_key_file_get_keys (_tmp15_, _tmp16_, &_tmp17_, &_inner_error_);
					_tmp19_ = _tmp18_;
					_tmp19__length1 = _tmp17_;
					__tmp19__size_ = _tmp19__length1;
					if (_inner_error_ != NULL) {
						goto __catch9_g_error;
					}
					keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
					keys = _tmp19_;
					keys_length1 = _tmp19__length1;
					_keys_size_ = keys_length1;
				}
				goto __finally9;
				__catch9_g_error:
				{
					GError* e = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					_g_error_free0 (e);
					keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
					_schema_unref0 (schema);
					_g_free0 (group);
					continue;
				}
				__finally9:
				if (_inner_error_ != NULL) {
					keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
					_schema_unref0 (schema);
					_g_free0 (group);
					group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
					_g_key_file_free0 (keyfile);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				_tmp20_ = keys;
				_tmp20__length1 = keys_length1;
				{
					gchar** key_name_collection = NULL;
					gint key_name_collection_length1 = 0;
					gint _key_name_collection_size_ = 0;
					gint key_name_it = 0;
					key_name_collection = _tmp20_;
					key_name_collection_length1 = _tmp20__length1;
					for (key_name_it = 0; key_name_it < _tmp20__length1; key_name_it = key_name_it + 1) {
						gchar* _tmp21_;
						gchar* key_name = NULL;
						_tmp21_ = g_strdup (key_name_collection[key_name_it]);
						key_name = _tmp21_;
						{
							gchar* value = NULL;
							Schema* _tmp27_;
							GHashTable* _tmp28_;
							const gchar* _tmp29_;
							gconstpointer _tmp30_ = NULL;
							SchemaKey* _tmp31_;
							SchemaKey* key;
							SchemaKey* _tmp32_;
							GVariant* default_value = NULL;
							SchemaKey* _tmp41_;
							GVariant* _tmp42_;
							GVariant* _tmp43_;
							{
								GKeyFile* _tmp22_;
								const gchar* _tmp23_;
								const gchar* _tmp24_;
								gchar* _tmp25_ = NULL;
								gchar* _tmp26_;
								_tmp22_ = keyfile;
								_tmp23_ = group;
								_tmp24_ = key_name;
								_tmp25_ = g_key_file_get_value (_tmp22_, _tmp23_, _tmp24_, &_inner_error_);
								_tmp26_ = _tmp25_;
								if (_inner_error_ != NULL) {
									goto __catch10_g_error;
								}
								_g_free0 (value);
								value = _tmp26_;
							}
							goto __finally10;
							__catch10_g_error:
							{
								GError* e = NULL;
								e = _inner_error_;
								_inner_error_ = NULL;
								_g_error_free0 (e);
								_g_free0 (value);
								_g_free0 (key_name);
								continue;
							}
							__finally10:
							if (_inner_error_ != NULL) {
								_g_free0 (value);
								_g_free0 (key_name);
								keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
								_schema_unref0 (schema);
								_g_free0 (group);
								group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
								_g_key_file_free0 (keyfile);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
							_tmp27_ = schema;
							_tmp28_ = _tmp27_->keys;
							_tmp29_ = key_name;
							_tmp30_ = g_hash_table_lookup (_tmp28_, _tmp29_);
							_tmp31_ = _schema_key_ref0 ((SchemaKey*) _tmp30_);
							key = _tmp31_;
							_tmp32_ = key;
							if (_tmp32_ == NULL) {
								_schema_key_unref0 (key);
								_g_free0 (value);
								_g_free0 (key_name);
								continue;
							}
							{
								SchemaKey* _tmp33_;
								const gchar* _tmp34_;
								GVariantType* _tmp35_;
								GVariantType* _tmp36_;
								const gchar* _tmp37_;
								GVariant* _tmp38_ = NULL;
								GVariant* _tmp39_;
								GVariant* _tmp40_;
								_tmp33_ = key;
								_tmp34_ = _tmp33_->type;
								_tmp35_ = g_variant_type_new (_tmp34_);
								_tmp36_ = _tmp35_;
								_tmp37_ = value;
								_tmp38_ = g_variant_parse (_tmp36_, _tmp37_, NULL, NULL, &_inner_error_);
								_tmp39_ = _tmp38_;
								_g_variant_type_free0 (_tmp36_);
								_tmp40_ = _tmp39_;
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
										goto __catch11_g_variant_parse_error;
									}
									_g_variant_unref0 (default_value);
									_schema_key_unref0 (key);
									_g_free0 (value);
									_g_free0 (key_name);
									keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
									_schema_unref0 (schema);
									_g_free0 (group);
									group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
									_g_key_file_free0 (keyfile);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_g_variant_unref0 (default_value);
								default_value = _tmp40_;
							}
							goto __finally11;
							__catch11_g_variant_parse_error:
							{
								GError* e = NULL;
								e = _inner_error_;
								_inner_error_ = NULL;
								_g_error_free0 (e);
								_g_variant_unref0 (default_value);
								_schema_key_unref0 (key);
								_g_free0 (value);
								_g_free0 (key_name);
								continue;
							}
							__finally11:
							if (_inner_error_ != NULL) {
								_g_variant_unref0 (default_value);
								_schema_key_unref0 (key);
								_g_free0 (value);
								_g_free0 (key_name);
								keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
								_schema_unref0 (schema);
								_g_free0 (group);
								group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
								_g_key_file_free0 (keyfile);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
							_tmp41_ = key;
							_tmp42_ = default_value;
							_tmp43_ = _g_variant_ref0 (_tmp42_);
							_g_variant_unref0 (_tmp41_->default_value);
							_tmp41_->default_value = _tmp43_;
							_g_variant_unref0 (default_value);
							_schema_key_unref0 (key);
							_g_free0 (value);
							_g_free0 (key_name);
						}
					}
				}
				keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
				_schema_unref0 (schema);
				_g_free0 (group);
			}
		}
		group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	_g_key_file_free0 (keyfile);
}


void schema_list_load_directory (SchemaList* self, const gchar* dir, GError** error) {
	const gchar* _tmp0_;
	GFile* _tmp1_ = NULL;
	GFile* directory;
	GFile* _tmp2_;
	GFileEnumerator* _tmp3_ = NULL;
	GFileEnumerator* i;
	GFile* _tmp20_;
	GFileEnumerator* _tmp21_ = NULL;
	GFileEnumerator* _tmp22_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	_tmp0_ = dir;
	_tmp1_ = g_file_new_for_path (_tmp0_);
	directory = _tmp1_;
	_tmp2_ = directory;
	_tmp3_ = g_file_enumerate_children (_tmp2_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
	i = _tmp3_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (directory);
		return;
	}
	while (TRUE) {
		GFileEnumerator* _tmp4_;
		GFileInfo* _tmp5_ = NULL;
		GFileInfo* info;
		GFileInfo* _tmp6_;
		GFileInfo* _tmp7_;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		gchar* name;
		gboolean _tmp10_ = FALSE;
		const gchar* _tmp11_;
		gboolean _tmp12_ = FALSE;
		gboolean _tmp15_;
		_tmp4_ = i;
		_tmp5_ = g_file_enumerator_next_file (_tmp4_, NULL, &_inner_error_);
		info = _tmp5_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (i);
			_g_object_unref0 (directory);
			return;
		}
		_tmp6_ = info;
		if (_tmp6_ == NULL) {
			_g_object_unref0 (info);
			break;
		}
		_tmp7_ = info;
		_tmp8_ = g_file_info_get_name (_tmp7_);
		_tmp9_ = g_strdup (_tmp8_);
		name = _tmp9_;
		_tmp11_ = name;
		_tmp12_ = g_str_has_suffix (_tmp11_, ".gschema.xml");
		if (_tmp12_) {
			_tmp10_ = TRUE;
		} else {
			const gchar* _tmp13_;
			gboolean _tmp14_ = FALSE;
			_tmp13_ = name;
			_tmp14_ = g_str_has_suffix (_tmp13_, ".enums.xml");
			_tmp10_ = _tmp14_;
		}
		_tmp15_ = _tmp10_;
		if (_tmp15_) {
			const gchar* _tmp16_;
			const gchar* _tmp17_;
			gchar* _tmp18_ = NULL;
			gchar* _tmp19_;
			_tmp16_ = dir;
			_tmp17_ = name;
			_tmp18_ = g_build_filename (_tmp16_, _tmp17_, NULL, NULL);
			_tmp19_ = _tmp18_;
			schema_list_parse_file (self, _tmp19_);
			_g_free0 (_tmp19_);
		}
		_g_free0 (name);
		_g_object_unref0 (info);
	}
	_tmp20_ = directory;
	_tmp21_ = g_file_enumerate_children (_tmp20_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
	_tmp22_ = _tmp21_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (i);
		_g_object_unref0 (directory);
		return;
	}
	_g_object_unref0 (i);
	i = _tmp22_;
	while (TRUE) {
		GFileEnumerator* _tmp23_;
		GFileInfo* _tmp24_ = NULL;
		GFileInfo* info;
		GFileInfo* _tmp25_;
		GFileInfo* _tmp26_;
		const gchar* _tmp27_ = NULL;
		gchar* _tmp28_;
		gchar* name;
		const gchar* _tmp29_;
		gboolean _tmp30_ = FALSE;
		_tmp23_ = i;
		_tmp24_ = g_file_enumerator_next_file (_tmp23_, NULL, &_inner_error_);
		info = _tmp24_;
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (i);
			_g_object_unref0 (directory);
			return;
		}
		_tmp25_ = info;
		if (_tmp25_ == NULL) {
			_g_object_unref0 (info);
			break;
		}
		_tmp26_ = info;
		_tmp27_ = g_file_info_get_name (_tmp26_);
		_tmp28_ = g_strdup (_tmp27_);
		name = _tmp28_;
		_tmp29_ = name;
		_tmp30_ = g_str_has_suffix (_tmp29_, ".override");
		if (_tmp30_) {
			const gchar* _tmp31_;
			const gchar* _tmp32_;
			gchar* _tmp33_ = NULL;
			gchar* _tmp34_;
			_tmp31_ = dir;
			_tmp32_ = name;
			_tmp33_ = g_build_filename (_tmp31_, _tmp32_, NULL, NULL);
			_tmp34_ = _tmp33_;
			schema_list_parse_override (self, _tmp34_);
			_g_free0 (_tmp34_);
		}
		_g_free0 (name);
		_g_object_unref0 (info);
	}
	_g_object_unref0 (i);
	_g_object_unref0 (directory);
}


SchemaList* schema_list_construct (GType object_type) {
	SchemaList* self = NULL;
	self = (SchemaList*) g_type_create_instance (object_type);
	return self;
}


SchemaList* schema_list_new (void) {
	return schema_list_construct (TYPE_SCHEMA_LIST);
}


static void value_schema_list_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_list_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_list_unref (value->data[0].v_pointer);
	}
}


static void value_schema_list_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_list_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_list_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_list_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaList* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_list_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_list_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaList** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_list_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_list (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaList* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_LIST), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_list (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_LIST), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_list (GValue* value, gpointer v_object) {
	SchemaList* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_LIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_LIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_list_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_list_unref (old);
	}
}


void value_take_schema_list (GValue* value, gpointer v_object) {
	SchemaList* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_LIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_LIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_list_unref (old);
	}
}


static void schema_list_class_init (SchemaListClass * klass) {
	schema_list_parent_class = g_type_class_peek_parent (klass);
	SCHEMA_LIST_CLASS (klass)->finalize = schema_list_finalize;
}


static void schema_list_instance_init (SchemaList * self) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GHashTable* _tmp2_;
	GHashFunc _tmp3_;
	GEqualFunc _tmp4_;
	GHashTable* _tmp5_;
	GHashFunc _tmp6_;
	GEqualFunc _tmp7_;
	GHashTable* _tmp8_;
	GHashFunc _tmp9_;
	GEqualFunc _tmp10_;
	GHashTable* _tmp11_;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _schema_unref0_);
	self->schemas = _tmp2_;
	_tmp3_ = g_str_hash;
	_tmp4_ = g_str_equal;
	_tmp5_ = g_hash_table_new_full (_tmp3_, _tmp4_, _g_free0_, _schema_key_unref0_);
	self->keys = _tmp5_;
	_tmp6_ = g_str_hash;
	_tmp7_ = g_str_equal;
	_tmp8_ = g_hash_table_new_full (_tmp6_, _tmp7_, _g_free0_, _schema_enum_unref0_);
	self->enums = _tmp8_;
	_tmp9_ = g_str_hash;
	_tmp10_ = g_str_equal;
	_tmp11_ = g_hash_table_new_full (_tmp9_, _tmp10_, _g_free0_, _schema_flags_unref0_);
	self->flags = _tmp11_;
	self->ref_count = 1;
}


static void schema_list_finalize (SchemaList* obj) {
	SchemaList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_LIST, SchemaList);
	_g_hash_table_unref0 (self->schemas);
	_g_hash_table_unref0 (self->keys);
	_g_hash_table_unref0 (self->enums);
	_g_hash_table_unref0 (self->flags);
}


GType schema_list_get_type (void) {
	static volatile gsize schema_list_type_id__volatile = 0;
	if (g_once_init_enter (&schema_list_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_list_init, value_schema_list_free_value, value_schema_list_copy_value, value_schema_list_peek_pointer, "p", value_schema_list_collect_value, "p", value_schema_list_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaListClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_list_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaList), 0, (GInstanceInitFunc) schema_list_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_list_type_id;
		schema_list_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaList", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_list_type_id__volatile, schema_list_type_id);
	}
	return schema_list_type_id__volatile;
}


gpointer schema_list_ref (gpointer instance) {
	SchemaList* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_list_unref (gpointer instance) {
	SchemaList* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_LIST_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



